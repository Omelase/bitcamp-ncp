<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>ex02</title>
  </head>
  <body>
    <h1>연산자 - 비트연산자</h1>
    <script>
      'use strict';

      let a = 0b01100100; //100
      let b = 0b11110000; //240

      console.log(a);
      console.log(b);
      //a & b == 01100000

      console.log('--------------------');

      console.log((a & b).toString(2)); //1100000(96) 앞이 0이면 7자리만 나옴
      //AND 비트 연산자
      // - 두 비트가 1일 때 1, 그외 0
      // - 특정 비트의 값만 추출할 때 사용한다.
      // - 1로 설정한 비트의 값은 그대로 통과하는 효과가 있다.

      //응용1
      // - 색상 값에서 빨강 색을 제거하기
      // - ex) 사진에서 빨강색 제거
      let color = 0xff00ff;
      console.log((color & 0x00ffff).toString(16)); //0x0000FF

      console.log('--------------------');

      console.log((a | b).toString(2)); //11110100
      //OR 비트 연산자
      // - 두 비트 중 하나라도 1이면 1, 그외 0
      // - AND 비즈 연산자와 반대로 동작
      // - 0비트는 그대로 통과, 1비트는 기존 값 제거

      //응용2
      // - 특정 색상을 강화하기
      // - ex) 빨강색 강화
      color = 0x283386;
      console.log(color.toString(2));
      console.log((color | 0x550000).toString(2)); //01010101
      //기존 빨강색: 00101000
      //빨강색 강화: 01010101
      //변경된 색상: 01111101

      console.log('--------------------');

      console.log((a ^ b).toString(2)); //10010100
      //XOR(exclusive OR) 비트 연산자
      // - 두 비트의 값이 다를 때 1, 그외 0

      console.log('--------------------');

      console.log((~a).toString(2)); //10011011
      //NOT 비트 연산자
      // - 모든 비트가 반전

      console.log('--------------------');

      a = 7; //00000111

      console.log((a * 2).toString(2)); //14
      console.log((a << 1).toString(2)); //1110(14)
      console.log((a * 4).toString(2)); //28
      console.log((a << 2).toString(2)); //11100(28)
      console.log((a * 8).toString(2)); //56
      console.log((a << 3).toString(2)); //111000(56)
      //<< 비트 이동 연산자
      // - 왼쪽으로 지정한 비트만큼 이동시킨다.
      // - 오른쪽의 빈 자리는 0으로 채운다.
      // - 1비트 이동할 때마다 *2한 효과가 있다.
      // - *2 연산 수행하는 것보다 비트 이동 연산자가 실행 속도 더 빠르다.
      //n 비트 이동 = 값 * 2**n

      console.log('--------------------');

      a = 100; //01100100

      console.log((a / 2).toString(2)); //50
      console.log((a >> 1).toString(2)); //0110010|0(50)
      console.log((a / 4).toString(2)); //25
      console.log((a >> 2).toString(2)); //011001|00(25)
      console.log((a / 8).toString(2)); //12.5
      console.log((a >> 3).toString(2)); //01100|100(12) //오버플로우일어나면 잘라버림

      a = -100; //11111111 11111111 11111111 10011100 //32비트. 음수는 양수의 보수 + 1

      console.log(a >> 1);
      console.log((a >> 1).toString(2)); //11111111 11111111 11111111 11001110|0 (-50(11001110))
      //>> 비트 이동 연산자
      // - 오른쪽으로 지정한 비트만큼 이동시킨다.
      // - 왼쪽의 빈 자리는 부호비트(양수:0, 음수:1)으로 채운다.
      // - 1비트 이동할 때마다 /2한 효과가 있다.
      // - /2 연산 수행하는 것보다 비트 이동 연산자가 실행 속도 더 빠르다.
      //n 비트 이동 = 값 / 2**n

      console.log('--------------------');

      a = 100;

      console.log(a >>> 1);
      console.log((a >>> 1).toString(2));
      //>>> 비트 이동 연산자
      // - 오른쪽으로 지정한 비트만큼 이동시킨다.
      // - 왼쪽의 빈 자리는 0으로 채운다. 음수를 비트 이동하면 양수로 바뀐다.
      // - 1비트 이동할 때마다 /2한 효과가 있다.
      // - /2 연산 수행하는 것보다 비트 이동 연산자가 실행 속도 더 빠르다.
      //n 비트 이동 = 값 / 2**n

      a = -100; //~~~1 10011100

      console.log(a >>> 1); //2147483598 //오른쪽으로 이동하는데 32비트중 맨 앞이 0이 되므로 숫자가 커짐
      console.log((a >>> 1).toString(2)); //11001110

      console.log('--------------------');
    </script>
  </body>
</html>
